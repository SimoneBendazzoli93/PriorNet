import copy
import cv2
import datetime
import matplotlib.pyplot as plt
import numpy as np
import os
from libs.util import MaskGenerator
from scipy.ndimage import morphology


def plot_callback(model, save_dir, masked, mask, ori):
    """Called at the end of each epoch, displaying our previous test images,
    as well as their masked predictions and saving them to disk
    model: compiled model
    save_dir: dir to save the figures
    masked: corruped image
    mask: the mask of artifacts
    ori: original image
    the last three arguments are tensors generated by test generator.
    """
    # Get samples & Display them        
    pred_img = model.predict([masked, mask])
    pred_time = datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')

    # Clear current output and display test images
    for i in range(len(ori)):
        _, axes = plt.subplots(1, 3, figsize=(20, 5))
        axes[0].imshow(masked[i, :, :, :])
        axes[1].imshow(pred_img[i, :, :, :] * 1.)
        axes[2].imshow(ori[i, :, :, :])
        axes[0].set_title('Masked Image')
        axes[1].set_title('Predicted Image')
        axes[2].set_title('Original Image')
        file_name = os.path.join(save_dir, 'img_{}_{}.png'.format(i, pred_time))
        plt.savefig(file_name)
        plt.close()


def corrupt_image(img_array, crop=[512, 512]):
    '''
    Parameters
    ----------
    img_array : array 
        arrays of original images to be inpainted.
    crop : list
        describing the shape of the images to be cropped 
        the default value is [512 512].

    Returns
    -------
    imgs : list
        corrupted image with random mask.
    masks : list
        the raw mask that corrupted the image.
    '''
    imgs, masks = [], []
    for ind in range(len(img_array)):
        im = img_array[ind]
        # Create masked array
        mask = MaskGenerator(*crop)
        sample_mask = mask.sample()
        im[sample_mask == 0] = 1
        # plt.imshow(im)

        # Store for prediction
        imgs.append(im)
        masks.append(sample_mask)
    return imgs, masks


def circular_tumor_mask(orig_mask, rad=3):
    '''
    get the original tumoral mask and fit a circle to the tumor  
    ----------
    orig_mask : array
        tumor mask.
    Returns
    -------
    img : array
        rounded circular mask fitted to the tumor region.
    '''
    height, width, channels = 512, 512, 3
    img = np.zeros((height, width, channels), np.uint8)

    gray = cv2.cvtColor(orig_mask, cv2.COLOR_BGR2GRAY)
    thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]

    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    areas = [cv2.contourArea(c) for c in contours]
    sorted_areas = np.sort(areas)
    for item in sorted_areas:
        cnt = contours[areas.index(item)]
        (x1, y1), radius = cv2.minEnclosingCircle(cnt)
        x1 = int(x1)
        y1 = int(y1)
        radius += rad
        radius = int(radius)
        cv2.circle(img, (x1, y1), radius, (1, 1, 1), -1)
    return img


def dilate_mask(mask, rad=5):
    '''
    dilating the tumor mask instead of circular region
    ----------
    mask : array
        the binary tumor mask.
    radius : int
        radius of dilation
    Returns
    -------
    temp_dilated : array
        dilated tumor mask.

    '''
    temp = morphology.grey_dilation(mask[:, :, 0], (rad, rad))
    temp_dilated = np.repeat(temp[:, :, np.newaxis], 3, axis=2)
    return temp_dilated


def mask_img(img_array, mask_array):
    masked_img = []
    length = img_array.shape[0]
    for ind in range(length):
        img = img_array[ind]
        mask = mask_array[ind]

        masked_in = copy.deepcopy(img)
        masked_in[mask == 1] = 1
        masked_img.append(masked_in)

    return masked_img


def predict(imgs, masks, model):
    '''
    imgs : list
        corrupted images.
    masks : list
        mask used to corrupt image.
    model : class
        compiled model with weight from phase2 training.

    Returns
    -------
    predictions : list
        prediction of the inpainted images.
    '''
    print('\n' * 5)
    print('predicting the images ...')
    print('\n' * 5)
    predictions = []
    for ix in range(len(imgs)):
        img = imgs[ix]
        mask = masks[ix]

        img = np.expand_dims(img, axis=0)
        mask = np.expand_dims(mask, axis=0)
        pred_imgs = np.squeeze(model.predict([img, mask]))
        predictions.append(pred_imgs)
    return predictions
